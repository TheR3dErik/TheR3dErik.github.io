[{"/Users/erik/Documents/webdev/ts_react_first/src/index.tsx":"1","/Users/erik/Documents/webdev/ts_react_first/src/MainPage.tsx":"2","/Users/erik/Documents/webdev/ts_react_first/src/util/ArticleCard.tsx":"3","/Users/erik/Documents/webdev/ts_react_first/src/pages/conductors/Conductors.tsx":"4","/Users/erik/Documents/webdev/ts_react_first/src/util/Vector2D.tsx":"5","/Users/erik/Documents/webdev/ts_react_first/src/util/Canvas.tsx":"6","/Users/erik/Documents/webdev/ts_react_first/src/pages/mspaintmatrix/MsPaintMatrix.tsx":"7","/Users/erik/Documents/webdev/ts_react_first/src/pages/photomosaic/PhotoMosaic.tsx":"8","/Users/erik/Documents/webdev/ts_react_first/src/pages/mandelbrot/Mandelbrot.tsx":"9","/Users/erik/Documents/webdev/ts_react_first/src/pages/quadtrees/Quadtrees.tsx":"10","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/index.tsx":"11","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/MainPage.tsx":"12","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/conductors/Conductors.tsx":"13","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/photomosaic/PhotoMosaic.tsx":"14","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/mspaintmatrix/MsPaintMatrix.tsx":"15","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/mandelbrot/Mandelbrot.tsx":"16","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/quadtrees/Quadtrees.tsx":"17","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/util/ArticleCard.tsx":"18","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/util/Canvas.tsx":"19","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/util/Vector2D.tsx":"20","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/tictactoe/Tictactoe.tsx":"21","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/tictactoe/Board.tsx":"22"},{"size":1032,"mtime":1608698593587,"results":"23","hashOfConfig":"24"},{"size":1975,"mtime":1609198927611,"results":"25","hashOfConfig":"24"},{"size":538,"mtime":1608517713364,"results":"26","hashOfConfig":"24"},{"size":6448,"mtime":1608692437045,"results":"27","hashOfConfig":"24"},{"size":671,"mtime":1608523344884,"results":"28","hashOfConfig":"24"},{"size":2354,"mtime":1609093846431,"results":"29","hashOfConfig":"24"},{"size":11043,"mtime":1608692455342,"results":"30","hashOfConfig":"24"},{"size":3614,"mtime":1608609061608,"results":"31","hashOfConfig":"24"},{"size":9713,"mtime":1609199210777,"results":"32","hashOfConfig":"24"},{"size":24174,"mtime":1609209094938,"results":"33","hashOfConfig":"24"},{"size":1149,"mtime":1621359543927,"results":"34","hashOfConfig":"35"},{"size":2220,"mtime":1622084783289,"results":"36","hashOfConfig":"35"},{"size":6448,"mtime":1621359346385,"results":"37","hashOfConfig":"35"},{"size":3614,"mtime":1621359346426,"results":"38","hashOfConfig":"35"},{"size":11043,"mtime":1621359346389,"results":"39","hashOfConfig":"35"},{"size":9713,"mtime":1621359346387,"results":"40","hashOfConfig":"35"},{"size":24174,"mtime":1621359346636,"results":"41","hashOfConfig":"35"},{"size":538,"mtime":1621359346640,"results":"42","hashOfConfig":"35"},{"size":2354,"mtime":1621359346640,"results":"43","hashOfConfig":"35"},{"size":671,"mtime":1621359346640,"results":"44","hashOfConfig":"35"},{"size":4217,"mtime":1622084497174,"results":"45","hashOfConfig":"35"},{"size":6506,"mtime":1622083833110,"results":"46","hashOfConfig":"35"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},"ji30iv",{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"49"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"61"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"49"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"49"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"49"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},"hgvg0j",{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"75"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"75"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"75"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"75"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"75"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"75"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"75"},"/Users/erik/Documents/webdev/ts_react_first/src/index.tsx",[],["100","101"],"/Users/erik/Documents/webdev/ts_react_first/src/MainPage.tsx",[],"/Users/erik/Documents/webdev/ts_react_first/src/util/ArticleCard.tsx",[],"/Users/erik/Documents/webdev/ts_react_first/src/pages/conductors/Conductors.tsx",["102","103","104"],"import React, { useEffect } from 'react';\nimport { Link } from 'react-router-dom';\nimport { Canvas } from '../../util/Canvas';\nimport Vec2D from '../../util/Vector2D';\n\nclass Charge {\n    pos: Vec2D;\n    vel: Vec2D;\n    charge: number;\n    fixed: boolean;\n\n    constructor(pos: Vec2D, charge: number, fixed: boolean) {\n        this.charge = charge;\n        this.pos = pos;\n        this.vel = new Vec2D(0, 0);\n        this.fixed = fixed;\n    }\n\n    render(c: CanvasRenderingContext2D): void {\n        if (this.charge > 0) {\n            c.fillStyle=\"#EE3300\";\n            c.beginPath();\n            c.arc(this.pos.x,this.pos.y,3,0,2*Math.PI,false);\n            c.fill();\n\n            c.lineWidth = 1\n            c.strokeStyle = \"#FFFFFF\"\n            c.beginPath();\n            c.moveTo(this.pos.x-2, this.pos.y)\n            c.lineTo(this.pos.x+2, this.pos.y)\n            c.moveTo(this.pos.x, this.pos.y-2)\n            c.lineTo(this.pos.x, this.pos.y+2)\n            c.stroke();\n        }\n        else {\n            c.fillStyle=\"#0099EE\";\n            c.beginPath();\n            c.arc(this.pos.x,this.pos.y,3,0,2*Math.PI,false);\n            c.fill();\n\n            c.lineWidth = 1\n            c.strokeStyle = \"#FFFFFF\"\n            c.beginPath();\n            c.moveTo(this.pos.x-2, this.pos.y)\n            c.lineTo(this.pos.x+2, this.pos.y)\n            c.stroke();\n        }\n    }\n\n    calc_accel(other_charge: Charge): Vec2D {\n        //var k = 1\n        var k = 0.5\n        var r = other_charge.pos.sub(this.pos)\n        //-2 for inverse, -3 for inverse square\n        var accel =  - k * this.charge * other_charge.charge * r.len_n(-2)\n\n        return r.mul(accel);\n    }\n}\n\nlet charges: Charge[] = [];\nlet conductor_radius: number = 200;\n\nfunction draw(c: CanvasRenderingContext2D, width: number, height: number): void {\n    c.fillStyle = \"#222222\";\n    c.fillRect(0,0,width, height);\n\n    c.lineWidth = 2\n    c.strokeStyle = \"#DDDD00\"\n    c.beginPath();\n    c.arc(width*0.5, height*0.5, conductor_radius,0,2*Math.PI,false);\n    c.stroke();\n\n    let accels: Vec2D[] = []\n\n    // finds total acceleration on each charge\n    for (var i = 0; i < charges.length; i++) {\n        let accel = new Vec2D(0,0)\n        for (var j = 0; j < charges.length; j++) {\n            if (i !== j) {\n                accel = accel.add(charges[i].calc_accel(charges[j]))\n            }\n        }\n        accels.push(accel)\n    }\n\n    // iterates through each charge and applies kinematics\n    for (var i = 0; i < charges.length; i++) {\n        if (charges[i].fixed)\n            continue;\n\n        charges[i].vel = charges[i].vel.add(accels[i])\n        charges[i].pos = charges[i].pos.add(charges[i].vel)\n\n        var centervec = new Vec2D(width*0.5, height*0.5)\n        var r = charges[i].pos.sub(centervec)\n\n        // collision detection against the edge of conductor\n        if (r.len() > conductor_radius) {\n            // cancels out velocity in direction of normal vector of the container\n            // effectively results in electrons \"sliding\" against wall rather than getting stuck to it\n            var n_vel_vec = r.mul(charges[i].vel.dot(r) * r.len_n(-2))\n            charges[i].vel = charges[i].vel.sub(n_vel_vec.mul(1.9))\n            let conductor_vec = r.mul(conductor_radius / r.len())\n            charges[i].pos = centervec.add(conductor_vec)\n        }\n    }\n\n    charges.forEach(function(arrayItem) {\n        arrayItem.render(c);\n    });\n}\n\nfunction init(width: number, height: number): void {\n    charges = [\n        //new Charge(new Vec2D(400,200),1, false),\n        //new Charge(new Vec2D(300,300),-1, false),\n        new Charge(new Vec2D(600,130), -100, true)\n        //new Charge(new Vec2D(300,198),-1)\n    ];\n\n    for (var y = 0; y < height; y += 20) {\n        for (var x = 0; x < width; x += 20) {\n            if ((x-width/2) * (x-width/2) + (y-height/2)*(y-height/2) > conductor_radius*conductor_radius)\n                continue;\n            charges.push(new Charge(new Vec2D(x,y), 1, true))\n        }\n    }\n\n    for (var y = 10; y < height; y += 20) {\n        for (var x = 10; x < width; x += 20) {\n            if ((x-width/2) * (x-width/2) + (y-height/2)*(y-height/2) > conductor_radius*conductor_radius)\n                continue;\n            charges.push(new Charge(new Vec2D(x,y), -1, false))\n        }\n    }\n}\n\nexport const Conductors = () => {\n    useEffect(() => {\n        document.title = \"Conductors\";\n        init(640, 480);\n    });\n\n    return (\n        <div className=\"mainContent\">\n            <Link to=\"/\">Back to main page</Link>\n            <Canvas contextType='2d' renderFunc={draw} width={640} height={480} />\n            <script src=\"conductors.js\"></script>\n            <p>While learning electrostatics for AP physics, my book made the claim that in an electrically neutral conductor, the electric field inside is zero and there is only a net charge on the surface.</p>\n            <p>So, I decided to try to get some more intuition for this claim by simulating a conductor as seen above. The positive nuclei of atoms are fixed in place and their electrons are free to flow around.\n                 I simply use Coulomb's law to calculate the attraction between every charge, and even with this many charges, it works well enough on a website. I fixed a single negative charge in place outside \n                 of the conductor with one hundred times the magnitude of charge compared to the individual particles in the conductor.\n            </p>\n            <p>I did make a slight modification to Coulomb's law. Basically, it seems that the charge only settles on the surface in 3 dimensions because the electric force obeys an inverse-square relationship with distance.\n                 However, this is a 2 dimensional simulation, so to get the same behavior, an inverse-square law no longer works. Instead, I modified it to be only inverse.\n            </p>\n            <p>This is still somewhat low resolution as far as atoms and electrons in a conductor go, so the result doesn't seem to be very clearly visible. But still, it does seem to work pretty well just by looking at it \n               (which admittedly isn't a very rigorous metric). Some further changes I could make to pursue this further would be to rewrite it in C++ to get enough of a performance boost to allow a finer grid with more \n               nuclei and electrons to be simulated.\n            </p>\n        </div>\n    );\n}\n\nexport default Conductors;","/Users/erik/Documents/webdev/ts_react_first/src/util/Vector2D.tsx",[],"/Users/erik/Documents/webdev/ts_react_first/src/util/Canvas.tsx",[],["105","106"],"/Users/erik/Documents/webdev/ts_react_first/src/pages/mspaintmatrix/MsPaintMatrix.tsx",["107","108","109","110","111","112","113"],"import React, { CSSProperties, useEffect, useRef, useState } from 'react';\nimport { Link } from 'react-router-dom';\n\nimport Tex2SVG from 'react-hook-mathjax'\n\nimport Canvas from '../../util/Canvas';\n\nimport './mspaintstyles.css';\n\nimport stockphotosign from './stockphotosign.jpg';\nimport step1 from './step1.png';\nimport step2 from './step2.png';\nimport step3 from './step3.png';\nimport step4 from './step4.png';\nimport finalresult from './finalresult.png';\nimport bobrossimg from './bobross.jpg';\n\nexport const MsPaintMatrix = () => {\n    const original_width_field_ref = useRef<HTMLInputElement>(null);\n    const original_height_field_ref = useRef<HTMLInputElement>(null);\n    const angle_field_ref = useRef<HTMLInputElement>(null);\n    const second_angle_field_ref = useRef<HTMLInputElement>(null);\n    const slider_ref = useRef<HTMLInputElement>(null);\n\n    const [calcWidthText, setCalcWidthText] = useState<string>('The new width is: ');\n    const [calcHeightText, setCalcHeightText] = useState<string>('The new height is: ');\n\n    const bobross_ref = useRef<HTMLImageElement>(null);\n\n    let smallimgstyle: CSSProperties = {\n        width: '30%'\n    };\n\n    let medimgstyle: CSSProperties = {\n        width: '60%'\n    };\n\n    let centerstyle: CSSProperties = {\n        textAlign: 'center'\n    };\n\n    let invis: CSSProperties = {\n        display: 'none'\n    }\n\n    function onTextFieldChange(): void {\n        let widthfield: number = parseInt(original_width_field_ref.current!.value);\n        let heightfield: number = parseInt(original_height_field_ref.current!.value);\n        let anglefield: number = parseInt(angle_field_ref.current!.value);\n\n        setCalcWidthText(\"The new width is: \"+Math.round(widthfield*Math.cos(anglefield*Math.PI/180)));\n        setCalcHeightText(\"The new height is: \"+Math.round(heightfield/Math.cos(anglefield*Math.PI/180)));\n    }\n\n    useEffect(() => {\n        document.title = \"Matrix!\";\n        onTextFieldChange();\n    });\n\n    function lerp(a: number, b: number, t: number): number {\n        return (1-t) * a + t * b;\n    }\n\n    function draw(c: CanvasRenderingContext2D, width: number, height: number) {\n        if (slider_ref.current == null) {\n            return;\n        }\n\n        c.setTransform(1, 0, 0, 1, 0, 0)\n        c.clearRect(0,0,640,480)\n        //c.setTransform(1, -slider.value * 0.001, 0, -1, 320, 240)\n        c.setTransform(1, 0, 0, 1, 320, 240)\n\n        let scalar: number;\n        let slidervalue: number = parseInt(slider_ref.current!.value);\n\n        // angle value is capped, converted to radians, and flipped to account for flipped y-axis on HTML5 canvas\n        let angle: number = parseInt(second_angle_field_ref.current!.value);\n        if (angle <= -180) {\n            angle = Math.PI;\n        }\n        else if (angle >= 180) {\n            angle = -Math.PI;\n        }\n        else {\n            angle = -angle * Math.PI / 180.0\n        }\n\n        if (slidervalue <= 333) {\n            scalar = slidervalue / 333.0;\n            c.transform(1,lerp(0,Math.tan(angle), scalar),0, 1, 0, 0)\n        }\n        else if (slidervalue <= 666) {\n            scalar = (slidervalue - 333) / 333.0\n            c.transform(1,Math.tan(angle), 0, 1, 0, 0)\n            c.transform(lerp(1,Math.cos(angle),scalar),0,0,lerp(1,1/Math.cos(angle),scalar),0,0)\n        }\n        else {\n            scalar = (slidervalue - 666) / 333.0\n            c.transform(1,Math.tan(angle), 0, 1, 0, 0)\n            c.transform(Math.cos(angle),0,0,1/Math.cos(angle),0,0)\n            c.transform(1, 0, lerp(0, -Math.tan(angle), scalar),  1, 0, 0)\n        }\n\n        //c.setTransform(Math.cos(getAngle()), Math.sin(getAngle()), -Math.sin(getAngle()), Math.cos(getAngle()), 0, 0)\n        c.fillStyle = \"#000000\"\n        //c.fillRect(-50,-50,100,100)\n        c.drawImage(bobross_ref.current!, -100, -100, 200, 200)\n    }\n\n    return (\n        <div className=\"mainContent\">\n            <Link to=\"/\">Back to main page</Link>\n            <h1>Actually rotating text in MS Paint</h1>\n            <p>The classic meme is that it is impossible to rotate text in Microsoft Paint. Outside of flipping and 90 degree rotations, this seems to be true. However, here I will prove that statement wrong using math.</p>\n            <h2>How to do it (explanation why is further down)</h2>\n            <p>Let's start by trying to add rotated text to this guy's stock photo sign below. I'm going to guess that we need to rotate it about 25 degrees clockwise. The plan is to rotate the whole image, place the text with no rotation, and rotate it back.</p>\n            <img className=\"step\" style={smallimgstyle} src={stockphotosign} />\n            <p>First, do a horizontal skew on the image by the ultimate amount you want to rotate. 25 degrees in this case.</p>\n            <img className=\"step\" style={medimgstyle} src={step1} />\n            <p>Now this step is slightly more complicated. Set the width to the original width of the image multiplied by the cosine of the angle. Set the height to the original height <i>divided</i> by the cosine of the angle.\n             This step is really only to scale the width by the cosine and height by the secant of the angle. The reason we don't scale by percent is that Microsoft Paint only lets you scale by integer percents so precision is lost.\n             Since this can be confusing, I've included a small helper below to calculate the new width and height of an image.</p>\n            <p>Original width: <input defaultValue={1000} onChange={onTextFieldChange} ref={original_width_field_ref} type=\"number\" id=\"widthfield\" min=\"0\" max=\"10000\" /></p>\n            <p>Original height: <input defaultValue={600} onChange={onTextFieldChange} ref={original_height_field_ref} type=\"number\" id=\"heightfield\" min=\"0\" max=\"10000\" /></p>\n            <p>Angle: <input defaultValue={0} onChange={onTextFieldChange} ref={angle_field_ref} type=\"number\" id=\"anglefield\" min=\"-89\" max=\"89\" /></p>\n            <br />\n            <p>{calcWidthText}</p>\n            <p>{calcHeightText}</p>\n            <img className=\"step\" style={medimgstyle} src={step2}></img>\n            <p>This final step is easier than before. Just do a vertical scale by the <i>negative</i> angle of rotation.</p>\n            <img className=\"step\" style={medimgstyle} src={step3}></img>\n            <p>Now put the text on:</p>\n            <img className=\"step\" style={smallimgstyle} src={step4}></img>\n            <p>And repeat these instructions but in reverse to get the final result:</p>\n            <img className=\"step\" style={smallimgstyle} src={finalresult}></img>\n            <p>Now for a few caveats. If your image is too large or too far from being a square, Microsoft Paint sometimes splices the image in a bizarre way when performing skews. Either resize or crop the image back to a smaller size or more square aspect ratio.\n                 Also, when rotating by an angle close to 90, such as 85 degrees, the extreme skewing will tend to lead to poor results. If you wish to rotate by such an angle, use the built-in feature to rotate first by 90 degrees and then rotate -5 degrees with this process.\n            </p>\n            <h2>Why it works</h2>\n            <p>Since matrices can also represent linear transformations, rotations can be written in terms of matrix multiplication. While a rotation cannot be represented in Microsoft Paint,\n                 the program does have support for shearing and scaling. So, if a rotation matrix can be broken down into a bunch of shears and scales, then in theory MS Paint would be able to support rotating text.\n            </p>\n            <p>Here is how a rotation can be represented as a matrix:</p>\n            <Tex2SVG latex=\"\\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}\" />\n            <p>In terms of linear transformations, the unit vector in the x direction gets mapped to the first column and the unit vector in the y direction gets mapped to the second column. \n                If that doesn't mean much to you, then try watching <a href=\"https://www.youtube.com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab\">the first three videos of 3blue1brown's essence of linear algebra series on YouTube.</a>\n                 If I tried to explain how matrices are linear transformations, this would turn into a bad copy of his videos.\n            </p>\n            <p>Now to try decomposing the rotation into a multiplication of triangular matrices. Since this matrix is only 2x2, it's a relatively straightforward process. \n                To the second row, add the first row multiplied by $-\\tan\\theta$ to eliminate the number in the lower left corner:</p>\n            <Tex2SVG latex=\"\\begin{bmatrix} 1 & 0 \\\\ -\\tan\\theta & 1 \\end{bmatrix}\\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} = \\begin{bmatrix} 1\\cdot\\cos\\theta + 0\\cdot\\sin\\theta & 1\\cdot(-\\sin\\theta) + 0\\cdot\\cos\\theta \\\\ -\\tan\\theta\\cdot\\cos\\theta + 1\\cdot\\sin\\theta & (-\\tan\\theta)\\cdot(-\\sin\\theta) + 1\\cdot\\cos\\theta \\end{bmatrix}\" />\n            <Tex2SVG latex=\" = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sec\\theta \\end{bmatrix}\" />\n            <p>And the matrix is factored. It can be written as follows:</p>\n            <Tex2SVG latex=\"\\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}= \\begin{bmatrix} 1 & 0 \\\\ \\tan\\theta & 1 \\end{bmatrix}\\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sec\\theta \\end{bmatrix}\" />\n            <p>However, MS Paint can only do shearing and scaling, so we have to break up the right-hand matrix. But this is only as hard as factoring out a diagonal matrix from it.</p>\n            <Tex2SVG latex=\"\\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}= \\begin{bmatrix} 1 & 0 \\\\ \\tan\\theta & 1 \\end{bmatrix}\\begin{bmatrix} \\cos\\theta & 0 \\\\ 0 & \\sec\\theta \\end{bmatrix}\\begin{bmatrix}1 & -\\tan\\theta \\\\ 0 & 1\\end{bmatrix}\" />\n            <p>The matrices with tangents in them happen to be the exact same transformation that MS Paint does when it performs a skew by a certain angle.\n                 So, reading the matrices right to left, to rotate an image, first perform a horizontal skew by the negative angle, then scale the x and y by the cosine and secant of the angle,\n                  and then perform vertical skew by the desired angle.\n            </p>\n            <p>This small program below demonstrates what exactly is going on with the math. Drag the slider to visualize each step of the transformation.</p>\n            <Canvas contextType='2d' renderFunc={draw} width={640} height={480} />\n            <input ref={slider_ref} type=\"range\" min=\"0\" defaultValue=\"0\" max=\"999\" step=\"1\" className=\"slider\" id=\"range1\" />\n            <p style={centerstyle}>Angle: <input ref={second_angle_field_ref} type=\"number\" defaultValue=\"30\" min=\"-180\" max=\"180\" id=\"angle1\" /></p>\n            <img style={invis} src={bobrossimg} ref={bobross_ref}/>\n        </div>\n    );\n}\n\nexport default MsPaintMatrix;","/Users/erik/Documents/webdev/ts_react_first/src/pages/photomosaic/PhotoMosaic.tsx",["114","115","116","117","118","119"],"import { Link } from 'react-router-dom';\n\nimport './photomosaicstyles.css';\n\nimport trenchpicoriginal from './trenchpicoriginal.jpg';\nimport try1 from './otherphotomosaictries/try1.jpg';\nimport try2 from './otherphotomosaictries/try2.jpg';\nimport try3 from './otherphotomosaictries/try3.jpg';\nimport try5_a from './otherphotomosaictries/try5_a.jpg';\n\nimport secondposter from './otherphotomosaictries/hereitis_secondposter.jpg';\n\nexport const PhotoMosaic = () => {\n    return(\n        <div className=\"mainContent\">\n            <Link to=\"/\">Back to main page</Link>\n            <h2>Photomosiac generator</h2>\n            <p>In my U.S. History class, we were assigned to create a photomosaic relating to World War 1. For anyone who doesn't know what it is, it's basically\n                a larger image made up of smaller ones, like the one in the thumbnail for this page.</p>\n            <p>Anyways, I decided to have a little fun with this and make the computer \n                do it for me on a scale much bigger than I could ever hope to do. I started with the base image below:\n            </p>\n            <img className=\"mosaicimg\" src={trenchpicoriginal} />\n            <p>Now I needed a quick way to download the first few hundred search results for World War 1 on Google. For this, I used <a href=\"https://github.com/hardikvasa/google-images-download\">this python library</a>\n                  to get the first few hundred images that pop up. The program ran out of images after it downloaded roughly 900 of them.</p>\n            <p>Then I sliced the base image into rectangular regions with a total of 32 across and 25 down. These subsections were sorted from lowest to highest average brightness.\n                The downloaded images were sorted in a similar fashion. The algorithm that follows is nothing complicated: each downloaded image was then matched with a subsection of similar brightness index.\n                This is the result:\n            </p>\n            <img className=\"mosaicimg\" src={try1} />\n            <p>It seems to work, but not well enough. My theory is that the distribution of brightnesses in the downloaded images is too far from that of the base image subsections.\n                In an attempt to account for this, I adjusted the brightness of each downloaded image to better match the base image. This produces a more well-defined result.\n            </p>\n            <img className=\"mosaicimg\" src={try2} />\n            <p>However, the original image still doesn't come through clearly enough. So, I blended it with the original image just a bit:</p>\n            <img className=\"mosaicimg\" src={try3} />\n            <p>One final idea I had was to duplicate each downloaded image 10 times so that we can have an even more well-defined photomosaic.\n                This has the unfortunate effect of causing the same images to cluster around each other because they have similar brightness.\n                But the final result is good enough that I think it's worth it.\n            </p>\n            <img className=\"mosaicimg\" src={try5_a} />\n            <p>We were also required to make a second photomosaic. My program can't sort with colors, so I just blended the colored base image more aggressively and still got this good result:</p>\n            <img className=\"mosaicimg\" src={secondposter} />\n            <p>One final note: If it seems difficult to distinguish individual subimages in the pictures above, it's because they are stored at a decreased resolution so the webpage loads more quickly.\n            </p>\n        </div>\n    );\n};\n\nexport default PhotoMosaic;","/Users/erik/Documents/webdev/ts_react_first/src/pages/mandelbrot/Mandelbrot.tsx",[],"/Users/erik/Documents/webdev/ts_react_first/src/pages/quadtrees/Quadtrees.tsx",["120","121"],"import { useEffect } from 'react';\nimport { Link } from 'react-router-dom';\nimport Canvas from '../../util/Canvas';\n\nimport './colorbuttonstyles.css';\n\nenum NodeType {\n    MIXED_TYPE = -1,\n    GREY,\n    BLUE,\n    GREEN,\n    BROWN,\n    RED\n}\n\ninterface BFSnode {\n    node: QuadtreeNode;\n    width: number;\n    height: number;\n    centerx: number;\n    centery: number;\n    depth: number;\n}\n\nlet typeColors = ['#999999', '#2288EE', '#5CCC00', '#9B7653', '#FF6600']\nlet selectedType = 0;\n\nclass Quadtree {\n    private root: QuadtreeNode;\n    private depthCap: number;\n    private centerx: number;\n    private centery: number;\n    private width: number;\n    private height: number;\n\n    private buffer: HTMLCanvasElement;\n    private bufferContext: CanvasRenderingContext2D;\n\n    constructor(depthCap: number, centerx: number, centery: number, width: number, height: number) {\n        this.root = new QuadtreeNode(0, depthCap);\n        this.depthCap = depthCap;\n        this.centerx = centerx;\n        this.centery = centery;\n        this.width = width;\n        this.height = height;\n\n        // this buffer is used for rendering the grid lines over the canvas with inverted colors\n        this.buffer = document.createElement(\"canvas\");\n        this.buffer.width = 512;\n        this.buffer.height = 512;\n        this.bufferContext = this.buffer.getContext('2d') as CanvasRenderingContext2D;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, drawGrid: boolean = true): void {\n        this.bufferContext.strokeStyle = '#FFFFFF';\n        this.bufferContext.clearRect(0, 0, 512, 512);\n        this.bufferContext.fillStyle = '#FFFFFF';\n        this.root.draw(ctx, this.bufferContext, this.centerx, this.centery, this.width, this.height);\n\n        if (drawGrid) {\n            ctx.globalCompositeOperation='difference';\n            ctx.drawImage(this.buffer, 0, 0);\n            ctx.globalCompositeOperation='source-over';\n        }\n    }\n\n    handleClick(type: NodeType, x: number, y: number, targetDepth: number) {\n        this.root.handleClick(type, x, y, targetDepth, 0, this.depthCap, this.centerx, this.centery, this.width, this.height);\n    }\n\n    drawHoverbox(ctx: CanvasRenderingContext2D, mousex: number, mousey: number, targetDepth: number) {\n        ctx.strokeStyle = '#FFFFFF';\n        //ctx.globalCompositeOperation='difference';\n        this.root.drawHoverbox(ctx, mousex, mousey, targetDepth, 0, this.depthCap, this.centerx, this.centery, this.width, this.height);\n        //ctx.globalCompositeOperation='source-over';\n    }\n\n    getNodeAt(cursorx: number, cursory: number, maxDepth: number = this.depthCap): undefined | BFSnode {\n        if (cursorx < 0 || cursory < 0 || cursorx > this.width || cursory > this.height) {\n            return undefined;\n        }\n        let current = this.root;\n        let centerx = this.centerx;\n        let centery = this.centery;\n        let width = this.width;\n        let height = this.height;\n        let depth = 0;\n        while (current.getType() === NodeType.MIXED_TYPE && depth < maxDepth) {\n            // top left\n            if (cursorx <= centerx && cursory <= centery) {\n                centerx -= width*0.25;\n                centery -= height*0.25;\n                current = current.getChild(0);\n            }\n            // bottom left\n            else if (cursorx <= centerx && cursory > centery) {\n                centerx -= width*0.25;\n                centery += height*0.25;\n                current = current.getChild(1);\n            }\n            // bottom right\n            else if (cursorx > centerx && cursory > centery) {\n                centerx += width*0.25;\n                centery += height*0.25;\n                current = current.getChild(2);\n            }\n            // top right\n            else {\n                centerx += width*0.25;\n                centery -= height*0.25;\n                current = current.getChild(3);\n            }\n            width *= 0.5;\n            height *= 0.5;\n            depth++;\n        }\n        return {node: current, width: width, height: height, centerx: centerx, centery: centery, depth: depth};\n    }\n\n    selectTest(cursorx: number, cursory: number) {\n        console.log(\"SELECT TEST\");\n        let current = this.getNodeAt(cursorx, cursory);\n        if (current === undefined) {\n            return;\n        }\n        console.log(\"not nll\");\n        /*\n        current.node.selected = true;\n\n        let topneighbors = current.node.getBottomNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth); topneighbors.forEach(e => {\n            e.node.selected = true;\n        });\n        topneighbors = current.node.getTopNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth); topneighbors.forEach(e => {\n            e.node.selected = true;\n        });\n        topneighbors = current.node.getRightNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth); topneighbors.forEach(e => {\n            e.node.selected = true;\n        });\n        */\n        let topneighbors = current.node.getLeftNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth); topneighbors.forEach(e => {\n            e.node.selected = true;\n        });\n       console.log(current.node.getLeftNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth));\n    }\n\n    // performs BFS to do a flood fill\n    floodFill(cursorx: number, cursory: number, fillColor: NodeType) {\n        let start = this.getNodeAt(cursorx, cursory);\n        if (start === undefined) {\n            return;\n        }\n\n        let startingColor = start.node.getType();\n        if (startingColor === fillColor) {\n            return;\n        }\n\n        let queue = [start];\n        while (queue.length > 0) {\n            let current = queue.shift();\n            if (current === undefined) {\n                continue;\n            }\n            current?.node.setType(fillColor, current.depth, this.depthCap);\n\n            let neighbors = current?.node.getTopNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth);\n            if (neighbors !== undefined) {\n                neighbors.forEach(e => {\n                    if (e.node.getType() === startingColor && !queue.includes(e)) {\n                        queue.push(e);\n                    }\n                });\n            }\n\n            neighbors = current?.node.getBottomNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth);\n            if (neighbors !== undefined) {\n                neighbors.forEach(e => {\n                    if (e.node.getType() === startingColor && !queue.includes(e)) {\n                        queue.push(e);\n                    }\n                });\n            }\n\n            neighbors = current?.node.getLeftNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth);\n            if (neighbors !== undefined) {\n                neighbors.forEach(e => {\n                    if (e.node.getType() === startingColor && !queue.includes(e)) {\n                        queue.push(e);\n                    }\n                });\n            }\n\n            neighbors = current?.node.getRightNeighbors(this, current.width, current.height, current.centerx, current.centery, current.depth);\n            if (neighbors !== undefined) {\n                neighbors.forEach(e => {\n                    if (e.node.getType() === startingColor && !queue.includes(e)) {\n                        queue.push(e);\n                    }\n                });\n            }\n        }\n        this.root.consolidate(0, this.depthCap);\n    }\n}\n\nclass QuadtreeNode {\n    // 0: top left\n    // 1: bottom left\n    // 2: bottom right\n    // 3: top right\n    private children: QuadtreeNode[];\n    public type: NodeType;\n    public selected: boolean = false;\n\n    constructor(depth: number, depthCap: number) {\n        this.type = 1; // hardcodes default as the \"sky\" looking color\n        this.children = [];\n\n        // if the node is not a leaf, add four children\n        if (depth < depthCap) {\n            for (let i = 0; i < 4; i++) {\n                this.children.push(new QuadtreeNode(depth + 1, depthCap));\n            }\n        }\n    }\n\n    getType() {\n        return this.type;\n    }\n\n    getChild(index: number) {\n        return this.children[index];\n    }\n\n    consolidate(depth: number, depthCap: number) {\n        if (depth === depthCap || this.type !== NodeType.MIXED_TYPE) {\n            return;\n        }\n\n        if (this.children[0].type !== NodeType.MIXED_TYPE && this.children[0].type === this.children[1].type && this.children[1].type === this.children[2].type && this.children[2].type === this.children[3].type) {\n            this.setType(this.children[0].type, depth, depthCap);\n        }\n        else {\n            this.type = NodeType.MIXED_TYPE;\n            this.children[0].consolidate(depth + 1, depthCap);\n            this.children[1].consolidate(depth + 1, depthCap);\n            this.children[2].consolidate(depth + 1, depthCap);\n            this.children[3].consolidate(depth + 1, depthCap);\n            if (this.children[0].type !== NodeType.MIXED_TYPE && this.children[0].type === this.children[1].type && this.children[1].type === this.children[2].type && this.children[2].type === this.children[3].type) {\n                this.setType(this.children[0].type, depth, depthCap);\n            }\n        }\n    }\n\n    getTopChildren(width: number, height: number, centerx: number, centery: number, depth: number): BFSnode[] {\n        if (this.type !== NodeType.MIXED_TYPE) {\n            return [{node: this, width: width, height: height, centerx: centerx, centery: centery, depth: depth}];\n        }\n\n        let nodeList: BFSnode[] = [];\n        nodeList.push(...this.children[0].getTopChildren(width*0.5, height*0.5, centerx - width*0.25, centery - height*0.25, depth + 1));\n        nodeList.push(...this.children[3].getTopChildren(width*0.5, height*0.5, centerx + width*0.25, centery - height*0.25, depth + 1));\n        return nodeList;\n    }\n\n    getBottomChildren(width: number, height: number, centerx: number, centery: number, depth: number): BFSnode[] {\n        if (this.type !== NodeType.MIXED_TYPE) {\n            return [{node: this, width: width, height: height, centerx: centerx, centery: centery, depth: depth}];\n        }\n\n        let nodeList: BFSnode[] = [];\n        nodeList.push(...this.children[1].getBottomChildren(width*0.5, height*0.5, centerx - width*0.25, centery + height*0.25, depth + 1));\n        nodeList.push(...this.children[2].getBottomChildren(width*0.5, height*0.5, centerx + width*0.25, centery + height*0.25, depth + 1));\n        return nodeList;\n    }\n\n    getLeftChildren(width: number, height: number, centerx: number, centery: number, depth: number): BFSnode[] {\n        if (this.type !== NodeType.MIXED_TYPE) {\n            return [{node: this, width: width, height: height, centerx: centerx, centery: centery, depth: depth}];\n        }\n\n        let nodeList: BFSnode[] = [];\n        nodeList.push(...this.children[0].getLeftChildren(width*0.5, height*0.5, centerx - width*0.25, centery - height*0.25, depth + 1));\n        nodeList.push(...this.children[1].getLeftChildren(width*0.5, height*0.5, centerx - width*0.25, centery + height*0.25, depth + 1));\n        return nodeList;\n    }\n\n    getRightChildren(width: number, height: number, centerx: number, centery: number, depth: number): BFSnode[] {\n        if (this.type !== NodeType.MIXED_TYPE) {\n            return [{node: this, width: width, height: height, centerx: centerx, centery: centery, depth: depth}];\n        }\n\n        let nodeList: BFSnode[] = [];\n        nodeList.push(...this.children[3].getRightChildren(width*0.5, height*0.5, centerx + width*0.25, centery - height*0.25, depth + 1));\n        nodeList.push(...this.children[2].getRightChildren(width*0.5, height*0.5, centerx + width*0.25, centery + height*0.25, depth + 1));\n        return nodeList;\n    }\n\n    getTopNeighbors(tree: Quadtree, width: number, height: number, centerx: number, centery: number, depth: number) {\n        let node = tree.getNodeAt(centerx, centery - height, depth);\n        if (node === undefined) {\n            return [];\n        }\n        if (node.node.type !== NodeType.MIXED_TYPE) {\n            return [node];\n        }\n        return node.node.getBottomChildren(width, height, centerx, centery - height, depth);\n    }\n\n    getBottomNeighbors(tree: Quadtree, width: number, height: number, centerx: number, centery: number, depth: number) {\n        let node = tree.getNodeAt(centerx, centery + height, depth);\n        if (node === undefined) {\n            return [];\n        }\n        if (node.node.type !== NodeType.MIXED_TYPE) {\n            return [node];\n        }\n        return node.node.getTopChildren(width, height, centerx, centery + height, depth);\n    }\n\n    getLeftNeighbors(tree: Quadtree, width: number, height: number, centerx: number, centery: number, depth: number) {\n        let node = tree.getNodeAt(centerx - width, centery, depth);\n        if (node === undefined) {\n            return [];\n        }\n        if (node.node.type !== NodeType.MIXED_TYPE) {\n            return [node];\n        }\n        return node.node.getRightChildren(width, height, centerx - width, centery, depth);\n    }\n\n    getRightNeighbors(tree: Quadtree, width: number, height: number, centerx: number, centery: number, depth: number) {\n        let node = tree.getNodeAt(centerx + width, centery, depth);\n        if (node === undefined) {\n            return [];\n        }\n        return node.node.getLeftChildren(width, height, centerx + width, centery, depth);\n    }\n\n    setType(type: NodeType, depth: number, depthCap: number) {\n        if (depth < depthCap) {\n            for (let i = 0; i < 4; i++) {\n                this.children[i].setType(type, depth + 1, depthCap);\n            }\n        }\n        this.type = type;\n    }\n\n    handleClick(type: NodeType, x: number, y: number, targetDepth: number, depth: number, depthCap: number, centerx: number, centery: number, width: number, height: number) {\n        if (type === this.type) {\n            return;\n        }\n\n        if (depth === targetDepth) {\n            this.setType(type, depth, depthCap);\n            return;\n        }\n\n        if (x <= centerx && y <= centery && this.children[0].type !== type) {\n            this.children[0].handleClick(type, x, y, targetDepth, depth + 1, depthCap, centerx - width*0.25, centery - height*0.25, width*0.5, height*0.5);\n        }\n        else if (x <= centerx && y > centery && this.children[1].type !== type) {\n            this.children[1].handleClick(type, x, y, targetDepth, depth + 1, depthCap, centerx - width*0.25, centery + height*0.25, width*0.5, height*0.5);\n        }\n        else if (x > centerx && y > centery && this.children[2].type !== type) {\n            this.children[2].handleClick(type, x, y, targetDepth, depth + 1, depthCap, centerx + width*0.25, centery + height*0.25, width*0.5, height*0.5);\n        }\n        else if (x > centerx && y <= centery && this.children[3].type !== type) {\n            this.children[3].handleClick(type, x, y, targetDepth, depth + 1, depthCap, centerx + width*0.25, centery - height*0.25, width*0.5, height*0.5);\n        }\n\n        // consolidates types\n        if (this.children[0].type === this.children[1].type && this.children[1].type === this.children[2].type && this.children[2].type === this.children[3].type)\n            this.type = this.children[0].type;\n        else\n            this.type = NodeType.MIXED_TYPE;\n    }\n\n    draw(ctx: CanvasRenderingContext2D, bctx: CanvasRenderingContext2D, centerx: number, centery: number, width: number, height: number) {\n        if (this.type === NodeType.MIXED_TYPE) {\n            this.children[0].draw(ctx, bctx, centerx - width*0.25, centery - height*0.25, width*0.5, height*0.5);\n            this.children[1].draw(ctx, bctx, centerx - width*0.25, centery + height*0.25, width*0.5, height*0.5);\n            this.children[2].draw(ctx, bctx, centerx + width*0.25, centery + height*0.25, width*0.5, height*0.5);\n            this.children[3].draw(ctx, bctx, centerx + width*0.25, centery - height*0.25, width*0.5, height*0.5);\n\n            // the lines draw faintly the first time, and the easiest way to make them more well defined is to just draw them more times\n            // it is somewhat clunky but it works well\n\n            for (let i = 0; i < 2; i++) {\n                bctx.beginPath();\n                bctx.moveTo(centerx - width*0.5, centery - height*0.5);\n                bctx.lineTo(centerx - width*0.5, centery + height*0.5);\n                bctx.lineTo(centerx + width*0.5, centery + height*0.5);\n                bctx.lineTo(centerx + width*0.5, centery - height*0.5);\n                bctx.lineTo(centerx - width*0.5, centery - height*0.5);\n                bctx.stroke();\n\n                bctx.beginPath();\n                bctx.moveTo(centerx - width*0.5, centery);\n                bctx.lineTo(centerx + width*0.5, centery);\n                bctx.stroke();\n\n                bctx.beginPath();\n                bctx.moveTo(centerx, centery - height*0.5);\n                bctx.lineTo(centerx, centery + height*0.5);\n                bctx.stroke();\n            }\n        }\n        else {\n            ctx.fillStyle = typeColors[this.type];\n            if (this.selected) {\n                ctx.fillStyle = '#FF00FF';\n            }\n            ctx.fillRect((centerx - width*0.5), (centery - height*0.5), width, height);\n        }\n    }\n\n    drawHoverbox(ctx: CanvasRenderingContext2D, x: number, y: number, targetDepth: number, depth: number, depthCap: number, centerx: number, centery: number, width: number, height: number) {\n        if (depth === targetDepth || depth === depthCap) {\n            ctx.beginPath();\n            ctx.moveTo(centerx - width*0.5, centery - height*0.5);\n            ctx.lineTo(centerx - width*0.5, centery + height*0.5);\n            ctx.lineTo(centerx + width*0.5, centery + height*0.5);\n            ctx.lineTo(centerx + width*0.5, centery - height*0.5);\n            ctx.lineTo(centerx - width*0.5, centery - height*0.5);\n            ctx.stroke();\n        }\n        else {\n            if (x <= centerx && y <= centery) {\n                this.children[0].drawHoverbox(ctx, x, y, targetDepth, depth + 1, depthCap, centerx - width*0.25, centery - height*0.25, width*0.5, height*0.5);\n            }\n            else if (x <= centerx && y > centery) {\n                this.children[1].drawHoverbox(ctx, x, y, targetDepth, depth + 1, depthCap, centerx - width*0.25, centery + height*0.25, width*0.5, height*0.5);\n            }\n            else if (x > centerx && y > centery) {\n                this.children[2].drawHoverbox(ctx, x, y, targetDepth, depth + 1, depthCap, centerx + width*0.25, centery + height*0.25, width*0.5, height*0.5);\n            }\n            else if (x > centerx && y <= centery) {\n                this.children[3].drawHoverbox(ctx, x, y, targetDepth, depth + 1, depthCap, centerx + width*0.25, centery - height*0.25, width*0.5, height*0.5);\n            }\n        }\n    }\n}\n\nexport const Quadtrees = () => {\n    let quadtree: Quadtree;\n    let dragging: boolean = false;\n    let brushSize: number = 6;\n    const MAX_BRUSH_SIZE: number = 6;\n    let mousex = 0.0;\n    let mousey = 0.0;\n    let drawGrid = true;\n\n    useEffect(() => {\n        // in this arrangement, the quadtree apparently gets reset after each time react renders, but react never needs to render again so this works for now\n        quadtree = new Quadtree(MAX_BRUSH_SIZE, 256, 256, 512, 512);\n    });\n\n    function handleCheckboxChange(e: React.ChangeEvent<HTMLInputElement>) {\n        drawGrid = e.target.checked;\n    }\n\n    function draw(ctx: CanvasRenderingContext2D) {\n        if (quadtree === undefined) {\n            console.log(\"Quadtree is undefined!!\");\n            return;\n        }\n\n        ctx.lineWidth = 2;\n        quadtree.draw(ctx, drawGrid);\n        quadtree.drawHoverbox(ctx, mousex, mousey, brushSize);\n    }\n\n    let colorButtons = []\n    colorButtons.push(<span><input onClick={() => selectedType=0} type=\"radio\" id={\"radio0\"} name=\"radios\" value={0} /><label style={{ backgroundColor: typeColors[0] }} htmlFor={\"radio0\"}></label></span>)\n    for (let i = 1; i < typeColors.length; i++) {\n        let id: string = \"radio\" + i;\n        colorButtons.push(<span><input onClick={() => selectedType=i} type=\"radio\" id={id} name=\"radios\" value={i} /><label style={{ backgroundColor: typeColors[i] }} htmlFor={id}></label></span>)\n    }\n    return (\n        <div className=\"mainContent\">\n            <Link to=\"/\">Back to main page</Link>\n            <Canvas contextType='2d' renderFunc={draw} width={512} height={512}\n                mouseDown = {(e: MouseEvent) => {\n                    quadtree.handleClick(selectedType, e.offsetX, e.offsetY, brushSize);\n                    dragging = true;\n                }}\n\n                mouseMove = {(e: MouseEvent) => {\n                    mousex = e.offsetX;\n                    mousey = e.offsetY;\n\n                    if (dragging) {\n                        quadtree.handleClick(selectedType, e.offsetX, e.offsetY, brushSize);\n                    }\n                }}\n\n                mouseUp = {(e: MouseEvent) => {\n                    dragging = false;\n                }}\n\n                mouseWheel = {(e: WheelEvent) => {\n                    if (e.deltaY > 0) {\n                        brushSize++;\n                    }\n                    else if (e.deltaY < 0) {\n                        brushSize--;\n                    }\n\n                    if (brushSize > MAX_BRUSH_SIZE) {\n                        brushSize = MAX_BRUSH_SIZE;\n                    } else if (brushSize < 0) {\n                        brushSize = 0;\n                    }\n                }}\n\n                mouseOut = {(e: MouseEvent) => {\n                    dragging = false;\n                }}\n\n                keyDown = {(e: KeyboardEvent) => {\n                    switch (e.key) {\n                        case 'i':\n                            brushSize++;\n                            if (brushSize > MAX_BRUSH_SIZE) {\n                                brushSize = MAX_BRUSH_SIZE;\n                            }\n                            break;\n                        case 'o':\n                            brushSize--;\n                            if (brushSize < 0) {\n                                brushSize = 0;\n                            }\n                            break;\n                        case 'f':\n                            quadtree.floodFill(mousex, mousey, selectedType);\n                            break;\n                        //case 's':\n                            //quadtree.selectTest(mousex, mousey);\n                            //break;\n                    }\n                }}\n            />\n            <div className=\"colorButtonDiv\"> {colorButtons} </div>\n            <input onChange={handleCheckboxChange.bind(this)} defaultChecked={true} type=\"checkbox\" id=\"gridRenderCheckbox\"/>\n            <label htmlFor=\"gridRenderCheckbox\">Render grid</label>\n            <p>Select a color to draw with by clicking on its square above. Then simply click and drag to draw. Press 'f' to perform a floodfill at the location of the mouse cursor with the selected color. Press 'o' to make the brush larger and 'i' to make it smaller.</p>\n            <p>Recently, I've been obsessed with making a voxel game similar to Minecraft. One thing I've read is how commonly octrees are used for this purpose. Before I try making anything with octrees, \n                I wanted to see if I could even use quadtrees, the more mild 2-dimensional cousins of octrees.</p>\n            <p>The canvas above is sort of like a picture in MS Paint that you can draw on, but it also visualizes the quadtree structure. For the most part, this wasn't too hard to implement, \n                but getting the flood fill to work properly was somewhat of a challenge.</p>\n        </div>\n    );\n}\n\nexport default Quadtrees;","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/index.tsx",[],["122","123"],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/MainPage.tsx",[],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/conductors/Conductors.tsx",["124","125","126"],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/photomosaic/PhotoMosaic.tsx",["127","128","129","130","131","132"],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/mspaintmatrix/MsPaintMatrix.tsx",["133","134","135","136","137","138","139"],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/mandelbrot/Mandelbrot.tsx",[],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/quadtrees/Quadtrees.tsx",["140","141"],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/util/ArticleCard.tsx",[],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/util/Canvas.tsx",[],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/util/Vector2D.tsx",[],"/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/tictactoe/Tictactoe.tsx",["142","143","144"],"import React, { useEffect } from 'react';\nimport { Link } from 'react-router-dom';\nimport { Canvas } from '../../util/Canvas';\nimport BoardState, { pickMoveRandomly, aiMove, buildLookup } from './Board';\n\nlet board: BoardState = BoardState.fromNumber(0);\nlet lookup: { [state: number] : string} = {};\n\nlet player1AI = true;\nlet player2AI = false;\n\nlet player1Turn = true;\nlet lastMoveTime = Date.now();\n\nconst aiMoveTime = 300;\n\nfunction draw(c: CanvasRenderingContext2D, width: number, height: number): void {\n    // updates game\n\n    // makes move for AI at the necessary time\n    let currentTime = Date.now();\n    if ( ( (player1Turn && player1AI) || (!player1Turn && player2AI) ) && currentTime - lastMoveTime > aiMoveTime) {\n        lastMoveTime = currentTime;\n        let move = aiMove(board, lookup);\n        board.makeMove(move[0], move[1]);\n\n        // changes player turn\n        player1Turn = !player1Turn;\n    }\n\n    // clears screen\n    c.fillStyle = \"#fef8f6\";\n    c.fillRect(0,0,width, height);\n\n    drawBoardState(c, board, width, height, 10);\n}\n\nfunction drawBoardState(c: CanvasRenderingContext2D, board: BoardState, width: number, height: number, linewidth: number): void {\n    // size of Xs and Os\n    let symbolsize = 90;\n\n    c.strokeStyle = \"#483d38\";\n    c.lineWidth = linewidth;\n\n    // draws grid\n    for (var x = 0; x < 2; x++) {\n        c.beginPath();\n        c.moveTo( (x+1) * width/3, 0);\n        c.lineTo( (x+1) * width/3, height);\n        c.stroke();\n    }\n    for (var y = 0; y < 2; y++) {\n        c.beginPath();\n        c.moveTo(0, (y+1) * height/3);\n        c.lineTo(width, (y+1) * height/3);\n        c.stroke();\n    }\n\n    // draws Xs and Os on board\n    for (var y = 0; y < 3; y++) {\n        for (var x = 0; x < 3; x++) {\n            if (board.getState()[y*3 + x] === 'X') {\n                c.beginPath();\n                c.moveTo(x * width/3 + width/6 - symbolsize/2, y * height/3 + height/6 - symbolsize/2);\n                c.lineTo(x * width/3 + width/6 + symbolsize/2, y * height/3 + height/6 + symbolsize/2);\n                c.stroke();\n\n                c.beginPath();\n                c.moveTo(x * width/3 + width/6 + symbolsize/2, y * height/3 + height/6 - symbolsize/2);\n                c.lineTo(x * width/3 + width/6 - symbolsize/2, y * height/3 + height/6 + symbolsize/2);\n                c.stroke();\n            }\n            else if (board.getState()[y*3 + x] === 'O') {\n                c.beginPath();\n                c.arc(x * width/3 + width/6, y * height/3 + height/6, symbolsize/2, 0, 2 * Math.PI);\n                c.stroke();\n            }\n        }\n    }\n}\n\nlet canvaswidth = 512;\nlet canvasheight = 512;\n\nexport const Tictactoe = () => {\n    useEffect(() => {\n        document.title = \"Tictactoe\";\n        let blank = BoardState.fromNumber(0);\n        buildLookup(blank, lookup);\n    });\n\n    return (\n        <div className=\"mainContent\">\n            <Link to=\"/\">Back to main page</Link>\n            <Canvas contextType='2d' renderFunc={draw} width={canvaswidth} height={canvasheight} \n                mouseDown = {(e: MouseEvent) => {\n                    if (board.findWinner() !== \"_\" || board.countType(\"_\") === 0 || (player1Turn && player1AI) || (!player1Turn && player2AI)) {\n                        return;\n                    }\n\n                    let xcoord = 2;\n                    let ycoord = 2;\n                    \n                    if (e.offsetX < canvaswidth / 3) {\n                        xcoord = 0;\n                    }\n                    else if (e.offsetX < 2 * canvaswidth / 3) {\n                        xcoord = 1;\n                    }\n\n                    if (e.offsetY < canvasheight / 3) {\n                        ycoord = 0;\n                    }\n                    else if (e.offsetY < 2 * canvasheight / 3) {\n                        ycoord = 1;\n                    }\n\n                    let index = 3 * ycoord + xcoord;\n                    let currentPlayer = board.getCurrentPlayer();\n                    board.makeMove(index, currentPlayer);\n\n                    lastMoveTime = Date.now();\n                    player1Turn = !player1Turn;\n                }}\n            />\n        </div>\n    );\n}\n\nexport default Tictactoe;","/Users/erik/Documents/webdev/TheR3dErik.github.io/src/pages/tictactoe/Board.tsx",["145","146","147","148","149","150","151","152","153","154"],"\nclass BoardState {\n    private state: Array<string>;\n\n    constructor(state: Array<string>) {\n        // creates copy of state\n        this.state = [...state];\n    }\n\n    public getState(): Array<string> {\n        return this.state;\n    }\n\n    // represents board state as ternary number for ease of indexing in lookup table\n    static fromNumber(state: number) {\n        let s = new Array<string>(9);\n        let bs  = new BoardState(s);\n\n        for (let i = 8; i >= 0; i--) {\n            let divisor = 3 ** i;\n            let remainder = state / divisor;\n            if (remainder < 1) {\n                bs.state[i] = '_';\n            }\n            else if (remainder < 2) {\n                bs.state[i] = 'X';\n                state -= divisor;\n            }\n            else {\n                bs.state[i] = 'O';\n                state -= 2*divisor;\n            }\n        }\n\n        return bs;\n    }\n\n    public toString(): string {\n        let s = \"\";\n        for (let row = 0; row < 3; row++) {\n            for (let col = 0; col < 3; col++) {\n                s += this.state[row * 3 + col];\n                s += \" \";\n            }\n            s += \"\\n\";\n        }\n\n        return s;\n    }\n\n    public toNumber(): number {\n        let res = 0;\n\n        let mult = 1;\n        for (var i = 0; i < 9; i++) {\n            if (this.state[i] === \"X\") {\n                res += mult;\n            }\n            else if (this.state[i] === \"O\") {\n                res += 2*mult;\n            }\n\n            mult *= 3;\n        }\n        return res;\n    }\n\n    public findWinner(): string {\n        let winningPatterns = [ [0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6] ]\n        for (let i = 0; i < winningPatterns.length; i++) {\n            let currentPattern = winningPatterns[i];\n\n            // excludes possibilility that all 3 positions are blank\n            if (this.state[currentPattern[0]] == \"_\")\n                continue;\n\n            // if all 3 match, a winner is found\n            if (this.state[currentPattern[0]] == this.state[currentPattern[1]] &&\n                this.state[currentPattern[1]] == this.state[currentPattern[2]]) {\n                    return this.state[currentPattern[0]];\n                }\n        }\n        // otherwise there is no winner\n        return \"_\";\n    }\n\n    public makeMove(index: number, player: string): Boolean {\n        // spot was already taken, move was unsuccessful\n        // or, invalid player was passed in\n        let legalMove = this.isMoveLegal(index, player);\n        if (!legalMove) {\n            return false;\n        }\n\n        this.state[index] = player;\n        return true;\n    }\n\n    public isMoveLegal(index: number, player: string): Boolean {\n        if (index < 0 || index >= 9 || this.state[index] != \"_\" || (player != \"X\" && player != \"O\") ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public getCurrentPlayer(): string {\n        // these could be theoretically done in one loop for the sake of \"efficiency\", but who cares?\n        let numX = this.countType(\"X\");\n        let numO = this.countType(\"O\");\n\n        let currentPlayer = \"X\";\n        if ((numX - numO) % 2 == 1) {\n            currentPlayer = \"O\";\n        }\n\n        return currentPlayer;\n    }\n\n    public getLegalMoves(): Array<[number, string]> {\n        let moves = new Array<[number, string]>();\n\n        let currentPlayer = this.getCurrentPlayer();\n\n        for (var i = 0; i < 9; i++) {\n            if (this.state[i] == \"_\") {\n                moves.push([i, currentPlayer]);\n            }\n        }\n\n        return moves;\n    }\n\n    public countType(type: string): number {\n        let count = 0;\n        for (var i = 0; i < 9; i++) {\n            if (this.state[i] == type) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n\nexport function pickMoveRandomly(moves: Array<[number, string]>): [number, string] {\n    return moves[Math.floor(Math.random() * moves.length)];\n}\n\nexport function aiMove(state: BoardState, lookup: { [state: number] : string}): [number, string] {\n    let moves = state.getLegalMoves();\n\n    let winningMoves = [];\n    let drawingMoves = [];\n    let losingMoves = [];\n\n    for (let i = 0; i < moves.length; i++) {\n        let move = moves[i];\n\n        let succ = BoardState.fromNumber(state.toNumber());\n        succ.makeMove(move[0], move[1]);\n\n        let winner = lookup[succ.toNumber()];\n        if (winner === state.getCurrentPlayer()) {\n            console.log(\"AI has determined winning move.\");\n            winningMoves.push(move);\n        }\n        else if (winner === \"_\") {\n            drawingMoves.push(move);\n        }\n        else {\n            losingMoves.push(move);\n        }\n    }\n\n    if (winningMoves.length > 0) {\n        return pickMoveRandomly(winningMoves);\n    }\n    else if (drawingMoves.length > 0) {\n        return pickMoveRandomly(drawingMoves);\n    }\n    else if (losingMoves.length > 0) {\n        return pickMoveRandomly(losingMoves);\n    }\n\n    // we should only reach this point when no moves are possible at all (board is full)\n    return [0, 'X'];\n}\n\nexport function buildLookup(state: BoardState, lookup: { [state: number] : string}): string {\n    let stateNum = state.toNumber();\n    if (stateNum in lookup) {\n        return lookup[stateNum];\n    }\n\n    let moves = state.getLegalMoves();\n    let currentPlayer = state.getCurrentPlayer();\n    let oppositePlayer = currentPlayer == \"X\" ? \"O\" : \"X\";\n    let winner = state.findWinner();\n\n    if (winner !== \"_\") {\n        lookup[stateNum] = winner;\n        return winner;\n    }\n\n    // if there are zero legal moves left and no winner, the position is a draw\n    if (moves.length === 0) {\n        lookup[stateNum] = \"_\";\n        return \"_\";\n    }\n\n    // assume position is losing by default\n    let winning = oppositePlayer;\n    for (var i = 0; i < moves.length; i++) {\n        let move = moves[i];\n\n        let succ = BoardState.fromNumber(state.toNumber());\n        succ.makeMove(move[0], move[1]);\n\n        let succWinning = buildLookup(succ, lookup);\n        // if the position evaluated so far is losing for the current player,\n        // the best we can do is the new node that we've found\n        if (winning === oppositePlayer) {\n            winning = succWinning;\n        }\n        else if (winning === \"_\" && succWinning === currentPlayer) {\n            winning = currentPlayer;\n        }\n    }\n    lookup[stateNum] = winning;\n    return winning;\n}\n\nexport default BoardState;",{"ruleId":"155","replacedBy":"156"},{"ruleId":"157","replacedBy":"158"},{"ruleId":"159","severity":1,"message":"160","line":88,"column":14,"nodeType":"161","messageId":"162","endLine":88,"endColumn":15},{"ruleId":"159","severity":1,"message":"163","line":130,"column":14,"nodeType":"161","messageId":"162","endLine":130,"endColumn":15},{"ruleId":"159","severity":1,"message":"164","line":131,"column":18,"nodeType":"161","messageId":"162","endLine":131,"endColumn":19},{"ruleId":"155","replacedBy":"165"},{"ruleId":"157","replacedBy":"166"},{"ruleId":"167","severity":1,"message":"168","line":118,"column":13,"nodeType":"169","endLine":118,"endColumn":80},{"ruleId":"167","severity":1,"message":"168","line":120,"column":13,"nodeType":"169","endLine":120,"endColumn":69},{"ruleId":"167","severity":1,"message":"168","line":130,"column":13,"nodeType":"169","endLine":130,"endColumn":67},{"ruleId":"167","severity":1,"message":"168","line":132,"column":13,"nodeType":"169","endLine":132,"endColumn":67},{"ruleId":"167","severity":1,"message":"168","line":134,"column":13,"nodeType":"169","endLine":134,"endColumn":69},{"ruleId":"167","severity":1,"message":"168","line":136,"column":13,"nodeType":"169","endLine":136,"endColumn":75},{"ruleId":"167","severity":1,"message":"168","line":166,"column":13,"nodeType":"169","endLine":166,"endColumn":68},{"ruleId":"167","severity":1,"message":"168","line":23,"column":13,"nodeType":"169","endLine":23,"endColumn":66},{"ruleId":"167","severity":1,"message":"168","line":30,"column":13,"nodeType":"169","endLine":30,"endColumn":53},{"ruleId":"167","severity":1,"message":"168","line":34,"column":13,"nodeType":"169","endLine":34,"endColumn":53},{"ruleId":"167","severity":1,"message":"168","line":36,"column":13,"nodeType":"169","endLine":36,"endColumn":53},{"ruleId":"167","severity":1,"message":"168","line":41,"column":13,"nodeType":"169","endLine":41,"endColumn":55},{"ruleId":"167","severity":1,"message":"168","line":43,"column":13,"nodeType":"169","endLine":43,"endColumn":61},{"ruleId":"170","severity":1,"message":"171","line":456,"column":20,"nodeType":"172","endLine":456,"endColumn":68},{"ruleId":"173","severity":1,"message":"174","line":478,"column":49,"nodeType":"175","messageId":"176","endLine":478,"endColumn":69},{"ruleId":"155","replacedBy":"177"},{"ruleId":"157","replacedBy":"178"},{"ruleId":"159","severity":1,"message":"160","line":88,"column":14,"nodeType":"161","messageId":"162","endLine":88,"endColumn":15},{"ruleId":"159","severity":1,"message":"163","line":130,"column":14,"nodeType":"161","messageId":"162","endLine":130,"endColumn":15},{"ruleId":"159","severity":1,"message":"164","line":131,"column":18,"nodeType":"161","messageId":"162","endLine":131,"endColumn":19},{"ruleId":"167","severity":1,"message":"168","line":23,"column":13,"nodeType":"169","endLine":23,"endColumn":66},{"ruleId":"167","severity":1,"message":"168","line":30,"column":13,"nodeType":"169","endLine":30,"endColumn":53},{"ruleId":"167","severity":1,"message":"168","line":34,"column":13,"nodeType":"169","endLine":34,"endColumn":53},{"ruleId":"167","severity":1,"message":"168","line":36,"column":13,"nodeType":"169","endLine":36,"endColumn":53},{"ruleId":"167","severity":1,"message":"168","line":41,"column":13,"nodeType":"169","endLine":41,"endColumn":55},{"ruleId":"167","severity":1,"message":"168","line":43,"column":13,"nodeType":"169","endLine":43,"endColumn":61},{"ruleId":"167","severity":1,"message":"168","line":118,"column":13,"nodeType":"169","endLine":118,"endColumn":80},{"ruleId":"167","severity":1,"message":"168","line":120,"column":13,"nodeType":"169","endLine":120,"endColumn":69},{"ruleId":"167","severity":1,"message":"168","line":130,"column":13,"nodeType":"169","endLine":130,"endColumn":67},{"ruleId":"167","severity":1,"message":"168","line":132,"column":13,"nodeType":"169","endLine":132,"endColumn":67},{"ruleId":"167","severity":1,"message":"168","line":134,"column":13,"nodeType":"169","endLine":134,"endColumn":69},{"ruleId":"167","severity":1,"message":"168","line":136,"column":13,"nodeType":"169","endLine":136,"endColumn":75},{"ruleId":"167","severity":1,"message":"168","line":166,"column":13,"nodeType":"169","endLine":166,"endColumn":68},{"ruleId":"170","severity":1,"message":"171","line":456,"column":20,"nodeType":"172","endLine":456,"endColumn":68},{"ruleId":"173","severity":1,"message":"174","line":478,"column":49,"nodeType":"175","messageId":"176","endLine":478,"endColumn":69},{"ruleId":"179","severity":1,"message":"180","line":4,"column":22,"nodeType":"161","messageId":"181","endLine":4,"endColumn":38},{"ruleId":"159","severity":1,"message":"163","line":60,"column":14,"nodeType":"161","messageId":"162","endLine":60,"endColumn":15},{"ruleId":"159","severity":1,"message":"164","line":61,"column":18,"nodeType":"161","messageId":"162","endLine":61,"endColumn":19},{"ruleId":"182","severity":1,"message":"183","line":74,"column":47,"nodeType":"184","messageId":"185","endLine":74,"endColumn":49},{"ruleId":"182","severity":1,"message":"183","line":78,"column":47,"nodeType":"184","messageId":"185","endLine":78,"endColumn":49},{"ruleId":"182","severity":1,"message":"183","line":79,"column":47,"nodeType":"184","messageId":"185","endLine":79,"endColumn":49},{"ruleId":"182","severity":1,"message":"186","line":100,"column":58,"nodeType":"184","messageId":"185","endLine":100,"endColumn":60},{"ruleId":"182","severity":1,"message":"186","line":100,"column":76,"nodeType":"184","messageId":"185","endLine":100,"endColumn":78},{"ruleId":"182","severity":1,"message":"186","line":100,"column":93,"nodeType":"184","messageId":"185","endLine":100,"endColumn":95},{"ruleId":"182","severity":1,"message":"183","line":113,"column":31,"nodeType":"184","messageId":"185","endLine":113,"endColumn":33},{"ruleId":"182","severity":1,"message":"183","line":126,"column":31,"nodeType":"184","messageId":"185","endLine":126,"endColumn":33},{"ruleId":"182","severity":1,"message":"183","line":137,"column":31,"nodeType":"184","messageId":"185","endLine":137,"endColumn":33},{"ruleId":"182","severity":1,"message":"183","line":197,"column":40,"nodeType":"184","messageId":"185","endLine":197,"endColumn":42},"no-native-reassign",["187"],"no-negated-in-lhs",["188"],"@typescript-eslint/no-redeclare","'i' is already defined.","Identifier","redeclared","'y' is already defined.","'x' is already defined.",["187"],["188"],"jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","react-hooks/exhaustive-deps","Assignments to the 'quadtree' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","NewExpression","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'selectedType'.","ArrowFunctionExpression","unsafeRefs",["187"],["188"],"@typescript-eslint/no-unused-vars","'pickMoveRandomly' is defined but never used.","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-global-assign","no-unsafe-negation"]